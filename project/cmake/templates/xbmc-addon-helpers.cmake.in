# Workaround for the fact that cpack's filenames are not customizable.
# Each add-on is added as a separate component to facilitate zip/tgz packaging.
# The filenames are always of the form basename-component, which is 
# incompatible with the addonid-version scheme we want. This hack renames
# the files from the file names generated by the 'package' target.
# Sadly we cannot extend the 'package' target, as it is a builtin target, see 
# http://public.kitware.com/Bug/view.php?id=8438
# Thus, we have to add an 'addon-package' target.
add_custom_target(addon-package
                  COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target package)

macro(add_cpack_workaround target version ext)
  add_custom_command(TARGET addon-package PRE_BUILD
                     COMMAND ${CMAKE_COMMAND} -E rename addon-${target}-${version}.${ext} ${target}-${version}.${ext})
endmacro()

# Grab the version from a given add-on's addon.xml
macro (addon_version dir prefix)
  file(READ ${dir}/addon.xml ADDONXML)
  string(REGEX MATCH "<addon[^>]*version.?=.?.[0-9\\.]+" VERSION_STRING ${ADDONXML}) 
  string(REGEX REPLACE ".*version=.([0-9\\.]+).*" "\\1" ${prefix}_VERSION ${VERSION_STRING})
  message(STATUS ${prefix}_VERSION=${${prefix}_VERSION})
endmacro()

# Build, link and optionally package an add-on
macro (build_addon target prefix libs)
  add_library(${target} ${${prefix}_SOURCES})
  target_link_libraries(${target} ${${libs}})
  addon_version(${target} ${prefix})
  SET_TARGET_PROPERTIES(${target} PROPERTIES VERSION ${${prefix}_VERSION}
                                             SOVERSION @APP_VERSION_MAJOR@.@APP_VERSION_MINOR@
                                             PREFIX "")
  if(OS STREQUAL "android")
    set_target_properties(${target} PROPERTIES PREFIX "lib")
  endif()

  # set zip as default if addon-package is called without PACKAGE_XXX
  set(CPACK_GENERATOR "ZIP")
  set(ext "zip")
  if(PACKAGE_ZIP OR PACKAGE_TGZ)
    if(PACKAGE_TGZ)
      set(CPACK_GENERATOR "TGZ")
      set(ext "tar.gz")
    endif()
    set(CPACK_INCLUDE_TOPLEVEL_DIRECTORY OFF)
    set(CPACK_PACKAGE_FILE_NAME addon)
    if(CMAKE_BUILD_TYPE STREQUAL "Release")
      set(CPACK_STRIP_FILES TRUE)
    endif()
    set(CPACK_ARCHIVE_COMPONENT_INSTALL ON)
    set(CPACK_COMPONENTS_IGNORE_GROUPS 1)
    list(APPEND CPACK_COMPONENTS_ALL ${target}-${${prefix}_VERSION})
    # Pack files together to create an archive
    install(DIRECTORY ${target} DESTINATION ./ COMPONENT ${target}-${${prefix}_VERSION})
    if(WIN32)
      install(PROGRAMS ${CMAKE_BINARY_DIR}/${target}.dll
              DESTINATION ${target}
              COMPONENT ${target}-${${prefix}_VERSION})
    else()
      install(TARGETS ${target} DESTINATION ${target}
              COMPONENT ${target}-${${prefix}_VERSION})
    endif(WIN32)
    add_cpack_workaround(${target} ${${prefix}_VERSION} ${ext})
  else()
    install(TARGETS ${target} DESTINATION lib/xbmc/addons/${target})
    install(DIRECTORY ${target} DESTINATION share/xbmc/addons)
  endif()
  if(XBMC_BUILD_DIR)
    file(GLOB_RECURSE files ${CMAKE_CURRENT_SOURCE_DIR}/${target}/*)
    foreach(file ${files})
      string(REPLACE "${CMAKE_CURRENT_SOURCE_DIR}/${target}/" "" name "${file}")
      # A good way to deal with () in filenames
      configure_file(${file} ${XBMC_BUILD_DIR}/addons/${target}/${name} COPYONLY)
    endforeach()
      add_custom_command(TARGET ${target} POST_BUILD
                        COMMAND ${CMAKE_COMMAND} -E copy
                                $<TARGET_LINKER_FILE:${target}>
                                ${XBMC_BUILD_DIR}/addons/${target}/$<TARGET_LINKER_FILE_NAME:${target}>)
  endif()
endmacro()

# finds a path to a given file (recursive)
function (xbmc_find_path var_name filename search_path strip_file)
  file(GLOB_RECURSE PATH_TO_FILE ${search_path} ${filename})
  if(strip_file)
    string(REPLACE ${filename} "" PATH_TO_FILE ${PATH_TO_FILE})
  endif(strip_file)
  set (${var_name} ${PATH_TO_FILE} PARENT_SCOPE)
endfunction()

# Cmake build options
include(addoptions)
include(TestCXXAcceptsFlag)
OPTION(PACKAGE_ZIP "Package Zip file?" OFF)
OPTION(PACKAGE_TGZ "Package TGZ file?" OFF)
OPTION(BUILD_SHARED_LIBS "Build shared libs?" ON)

# LTO support?
check_cxx_accepts_flag("-flto" HAVE_LTO)
if(HAVE_LTO)
  option(USE_LTO "use link time optimization" OFF)
  if(USE_LTO)
    add_options(ALL_LANGUAGES ALL_BUILDS "-flto")
  endif()
endif() 

# set this to try linking dependencies as static as possible
IF(ADDONS_PREFER_STATIC_LIBS)
  SET(CMAKE_FIND_LIBRARY_SUFFIXES .lib .a ${CMAKE_FIND_LIBRARY_SUFFIXES})
ENDIF(ADDONS_PREFER_STATIC_LIBS)

# Needed to quell warning about passed option being unused
# when reconfigured
set(CMAKE_PREFIX_PATH ${CMAKE_PREFIX_PATH})
set(BOOTSTRAP_IN_TREE ${BOOTSTRAP_IN_TREE})
